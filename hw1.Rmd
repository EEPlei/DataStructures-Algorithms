```{r}
source("graph.r")
```

```{r}
#Visualize Graph
#First we want to start off with a standard list function to help us transition to the "edge" function below
##STILL NEED TO WORK ON WHERE TO PLACE DIRECTED AND UNDIRECTED EDGES
graph1 = list(A = list(edges   = c(2L, 5L, 6L),
                   weights = c(6, 1, 3)),
          B = list(edges   = c(1L, 3L, 6L),
                   weights = c(6, 4, 13)),
          C = list(edges   = c(2L, 6L),
                   weights = c(4, 7)),
          D = list(edges   = c(5L, 6L),
                   weights = c(10, 12 )),
          E = list(edges   = c(1L, 4L, 6L),
                   weights = c(1, 10, 5)),
          F = list(edges   = c(1L, 2L, 3L, 4L, 5L),
                   weights = c(3, 13, 7, 12, 5))
                  )
# g1 is an undirected graph #
str(graph1)
graph2 = list(A = list(edges   = c(2L),
                   weights = c(1 )),
          B = list(edges   = c(3L),
                   weights = c(1 )),
          C = list(edges   = c(5L),
                   weights = c(1 )),
          D = list(edges   = c(2L),
                   weights = c(1 )),
          E = list(edges   = c(4L,6L),
                   weights = c(1,1  )),
          F = list(edges   = c(),
                   weights = c())
             )
# g2 is the graph example from class - should be directed #
str(graph2)

#is_valid function
#check if the graph is a list
#check if the names for every element are all unique
#check if every element is a list
#check if every element only contains edges and weights that are of the appropriate type
#check there are any edges to non-existent vertices
#check if all weights are not less than or equal to 0
#check if every edge has a weight
is_valid <- function(g){
  if(typeof(g)!="list")
    return(FALSE)
  if(length(g) != length(unique(names(g))))
    return(FALSE)
  for(i in 1:length(g)){
    if(typeof(g[[i]]) != "list")
      return(FALSE)
    if(all(names(g[[i]]) != c("edges","weights")))
      return(FALSE)
    if(typeof(g[[i]]$edges) != "integer" & typeof(g[[i]]$edges) != "NULL")
      return(FALSE)
    if(class(g[[i]]$weights) != "numeric" & class(g[[i]]$weights) != "NULL")
      return(FALSE)
    if(any(g[[i]]$edges>length(g)) | any(g[[i]]$edges<1))
      return(FALSE)
    if(any(g[[i]]$weights <= 0))
      return(FALSE)
    if(length(g[[i]]$edges) != length(g[[i]]$weights))
      return(FALSE)
  }
  return(TRUE)
}
#g <- Team4Graph



#edge
#edge function will return a data frame which is a table summarizing all edges.
#Its first column stores the starting vertices and its second column stores the ending vertics
#Its third column stores the edge length
edge <- function(g){
  # function where input is 'g' #
  output <- data.frame(start = numeric(), end = numeric(), weight = numeric(),stringsAsFactors =F)
  # makes an empty dataframe. where the horizontal header has "start", "end", and "weight" # 
  # numeric() creates a zero vector for each column #
  for(i in 1:length(g)){
    cur <- g[i]
    curvec <- unlist(cur)
    num_to <- length(curvec)/2 
    #number of vertices the current vertex goes to #
    if(num_to==0)
      next
    for(j in 1:num_to){
      newedge <- c(i,curvec[j],curvec[j+num_to])
      output <- rbind(output,setNames(as.list(newedge), names(output)))
    }
    #convert numbers to letters
    for(m in 1:length(output$start)){
      for(n in 1:length(g)){
        if(output$start[m] == n)
          output$start[m] = replace(output$start[m],,names(g[n]))
        if(output$end[m] == n)
          output$end[m] = replace(output$end[m],,names(g[n]))
      } 
    }
  }
  return(output)
}
# ForLoop, i can take on any numbers between 1 and the length of g. #
# cur is any of the elements within input 'g' #
# length(g) in the case of a list, will produce the number of elements #
# in the outer-most list #
# if cur is a list, unlist(cur) will take all the elements inside cur and changes it into a vector #
# it is then stored in variable 'curvec' #
# num_to takes the length of vector 'curvec' and divides it by 2 #
# if num_to is 0, it means that there were zero elements within cur #
# next() tells R to just skip/ignore this case #
# otherwise, take any number j from the range 1 to the num_to (the number of# 
# elements in cur) and use it to subset curvec #
# newedge is a new vector (current vertex, edge in vertex, corresponding weight) #

#is_undirected
#to check whether its edge data frame is symmetric
is_undirected <- function(g){
  edges <- edge(g)
  for(i in 1:nrow(edges)){
    istart <- edges[i,]$start
    iend <- edges[i,]$end
    iweight <- edges[i,]$weight
    if(nrow(edges[edges$start == iend & edges$end == istart,]) == 0)
      return(FALSE)
    if(edges[edges$start == iend & edges$end == istart,]$weight != iweight)
      return(FALSE)
  } 
  return(TRUE)
}

is_isomorphic = function(g1, g2){
  if(length(g1) != length(g2)){
    stop("Two graphs do not have same number of vertices")
  } 
  for(g1V in 1:length(g1)){
    if(!(TRUE %in% (names(g1[g1V]) == names(g2)))){
      stop("Name of vertices are not the same")}
      g2V = which(names(g1[g1V]) == names(g2))
      if(length(unlist(g1[[g1V]])) != length(unlist(g2[[g2V]]))){
          stop("Vertices do not have the same number of edges")
        } 
      for(k in 1:(length(unlist(g1[[g1V]])))/2){
        g1V2 = g1[[g1V]]$edges[k]
        g2V2 = which(names(g1[g1V2]) == names(g2))
        if(length(!(g2V2 %in% g2[[g2V]]$edges))>0)
        if(!(g2V2 %in% g2[[g2V]]$edges)){
          stop("Graphs are not isomorphic")}
        else return("Pass")
      } 
    } 
}
 # will search for the ith vertex name of g1 in g2 #
      # so if the jth vertex of g2 has the same name as #
      # the ith vertex name in g1, it will return a logical #
      # vector where the jth element is TRUE #
      # So if TRUE is not in that vector # 
      # R will stop running the function #
      # and return the error message #
      # that the vertices do not have the same names #
# since g1[i] == names(g2) will return a logical vector #
      # with one entry that is true #
      # we can use which() to tell us which element it is #
# unlisting each vertex of a graph will give us # 
      # the the number of edges and the number of weights #
      # so if there are n edges, and n corresponding weights #
      # the number we will get back is 2n # 
      # finding the length of a vertex from g1 and comparing #
      # it to the length of the same name vertex in g2 # 
      # will tell us if they have the same number of edges #
      # if they don't, an error message will appear #

    # is_undirected already tells me that each vertex's directed edge #
    # has a corresponding edge with the same weight coming back #

    # All I have to do, is figure out if each g1's vectors are going #
    # to the same vectors g2's vectors are going to #
# we already know that ith vertex of g1 and cth vertex of g1 #
      # are connected with an undirected edge #
      # earlier, we made sure that each vertex in g1 #
      # has a matching one (j) in g2 with the same name #
      # the dth vertex in g2 has the same name as cth in g1 #
      # if d is not in the edges vector for the jth vertex #
      # it means that although i connects to c in g1 #
      # the vertex with the same name, j does not connect to #
      # d which has the same name as c in g2 #


#This function is for taking difference between two data frames
diff_df <- function(df1,df2,...){
  expr <- paste("subset(df1,", paste(sapply(names(df1), function(x){paste("!(", x, " %in% df2$", x, ")", sep="")}), collapse=" | "), ")")
  eval(parse(text=expr))
}


#is_connected function
is_connected <- function(g, v1, v2) {
    edges <- edge(g)
    return(is_connected_helper(edges, v1, v2, c())) 
    # call up is_connected_helper, to use the "seen" array : this is to prevent infinite loops
}

is_connected_helper <- function(edges, v1, v2, seen) {
  #"seen" array denotes the vertices that I've already passed 
    if (length(seen) > 0) { #loop continues even when seen =0..weird
        for (i in 1:length(seen)) {
            if (v1 == seen[i]) {
                return(FALSE) # return FALSE if we've already passed the "seen" vector with our v1
            }
        }
    }
    seen <- c(v1, seen) # insert v1 in the "seen" array
    for (i in 1:nrow(edges)) {
        istart <- edges[i,1] # start column vector
        iend <- edges[i,2] #end column vector
        if (istart == v1 & (iend == v2 | is_connected_helper(edges, iend, v2, seen))) { 
        #1) if edge start is v1 and edge end is v2 
        #  or
        #2) if edge start is v1 and edge end is some other vertex other than v2 
          return(TRUE)
        }
    }
    return(FALSE)
}



#shortest path
shortest_path <- function(g,v1,v2){
  if(!is_valid(g)){
    stop("Please input a valid graph.")
  }
  #The following code will apply Dijkstra's Algorithm
  edges <- edge(g)
  vinfo <- data.frame(v = character(),dist = numeric(),prev = character(),stringsAsFactors =F)
  unvisited <- names(g)
  for(vert in unvisited){
    newvert <- list(as.character(vert),Inf,"undefined")
    vinfo <- rbind(vinfo,setNames(as.list(newvert), names(vinfo)))
  }
  
  vinfo[vinfo$v == v1,]$dist <- 0
  
  while(length(unvisited)!=0){
    temp <- vinfo[vinfo$v %in% unvisited,]
    u <- temp[temp$dist == min(temp$dist),][1,]$v   #vertex in unvisited with min dist[u]  
     if(temp[temp$v == u,]$dist == Inf){
       return(c())
     }
    unvisited <- unvisited[unvisited != u]          #remove u from unvisited
    
    for(vert in edges[edges$start == u,]$end){      #for each neighbor u can go to
      d <- vinfo[vinfo$v == u,]$dist + edges[edges$start == u & edges$end == vert,]$weight
      if(d < vinfo[vinfo$v == vert,]$dist){                           # A shorter path to vert has been found
        vinfo[vinfo$v == vert,]$dist <- d
        vinfo[vinfo$v == vert,]$prev <- u
      }
    }
  }
  path <- v2
  vert <- v2
  while(vinfo[vinfo$v == vert,]$prev != "undefined"){
    path <- c(path,vinfo[vinfo$v == vert,]$prev)
    vert <- vinfo[vinfo$v == vert,]$prev
  }
  
  return(rev(path))
}



#minimum spanning tree
min_span_tree <- function(g){
  if(!is_valid(g)){
    stop("Please input a valid graph.")
  }
  
  if(!is_undirected(g)){
    stop("Please input an undirected graph")
  }
  
  edges <- edge(g)
  #Remove redundancies for the edge table of an Undirected graph
  edges <- edges[edges$start < edges$end,]
  #The following code will apply Prim's Algorithm
  edges <- edges[order(edges$weight,edges$start,edges$end),]
  MST <- edges[1,]
  vertices <- c(MST$start,MST$end) #record all the vertices in MST
  while(nrow(MST) < length(g) - 1){
    neighbor <- edges[(edges$start %in% vertices | edges$end %in% vertices) & (!(edges$start %in% vertices) | !(edges$end %in% vertices)),]
    #neighbor <- diff_df(neigbor,MST)
    #protection for non-connected components
    if(nrow(neighbor) == 0){
      stop("The input graph is not connected.")
    }
    MST <- rbind(MST,setNames(as.list(neighbor[1,]), names(MST)))
    vertices <- c(vertices,MST$start,MST$end)
  }
  return(MST)
}
```
