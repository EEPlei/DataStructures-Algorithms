Homework 1 - Team 4 Duke Dinosaurs
========================================================
```{r}
#Visualize Graph
#First we want to start off with a standard list function to help us transition to the "edge" function below
##STILL NEED TO WORK ON WHERE TO PLACE DIRECTED AND UNDIRECTED EDGES
graph1 = list(A = list(edges   = c(2L, 5L, 6L),
                   weights = c(6, 1, 3)),
          B = list(edges   = c(1L, 3L, 6L),
                   weights = c(6, 4, 13)),
          C = list(edges   = c(2L, 6L),
                   weights = c(4, 7)),
          D = list(edges   = c(5L, 6L),
                   weights = c(10, 12 )),
          E = list(edges   = c(1L, 4L, 6L),
                   weights = c(1, 10, 5)),
          F = list(edges   = c(1L, 2L, 3L, 4L, 5L),
                   weights = c(3, 13, 7, 12, 5))
                  )
# g1 is an undirected graph #
str(graph1)
graph2 = list(A = list(edges   = c(2L),
                   weights = c(1 )),
          B = list(edges   = c(3L),
                   weights = c(1 )),
          C = list(edges   = c(5L),
                   weights = c(1 )),
          D = list(edges   = c(2L),
                   weights = c(1 )),
          E = list(edges   = c(4L,6L),
                   weights = c(1,1  )),
          F = list(edges   = c(),
                   weights = c())
             )
# g2 is the graph example from class - should be directed #
str(graph2)

#is_valid function
is_valid <- function(g){
  #below is to check if the graph is a list
  if(typeof(g)!="list")
    return(FALSE)
  #below is to check if the names for every element are all unique
  if(length(g) != length(unique(g)))
    return(FALSE)  
  for(i in 1:length(g)){
    #below is to check if every element is a list
    if(typeof(g[[i]]) != "list")
      return(FALSE)
    #below is to check if every element only contains edges and weights that are of the appropriate type
    if(all(names(g[[i]]) != c("edges","weights")) | all(typeof(g[[i]]$edges) != "integer") | all(class(g[[i]]$weights) != "numeric"))
      return(FALSE)
    #below is to check there are any edges to non-existent vertices
    if(any(g[[i]]$edges>length(g)) | any(g[[i]]$edges<=1))
      return(FALSE)
    #below is to check if all weights are not less than or equal to 0
    if(any(g[[i]]$weights <= 0))
      return(FALSE)
    #below is to check if every edge has a weight
    if(length(g[[i]]$edges) != length(g[[i]]$weights))
      return(FALSE)
  }
  return(TRUE)
}


#g <- Team4Graph



#edge
#edge function will return a data frame which is a table summarizing all edges.
#Its first column stores the starting vertices and its second column stores the ending vertics
#Its third column stores the edge length
edge <- function(g){
  # function where input is 'g' #
  output <- data.frame(start = numeric(), end = numeric(), weight = numeric())
  # makes an empty dataframe. where the horizontal header has "start", "end", and "weight" # 
  # numeric() creates a zero vector for each column #
  for(i in 1:length(g)){
    cur <- g[i]
    curvec <- unlist(cur)
    num_to <- length(curvec)/2 
    #number of vertices the current vertex goes to #
    if(num_to==0)
      next
    for(j in 1:num_to){
      newedge <- c(i,curvec[j],curvec[j+num_to])
      output <- rbind(output,setNames(as.list(newedge), names(output)))
    }
  }
  return(output)
}
# ForLoop, i can take on any numbers between 1 and the length of g. #
# cur is any of the elements within input 'g' #
# length(g) in the case of a list, will produce the number of elements #
# in the outer-most list #
# if cur is a list, unlist(cur) will take all the elements inside cur and changes it into a vector #
# it is then stored in variable 'curvec' #
# num_to takes the length of vector 'curvec' and divides it by 2 #
# if num_to is 0, it means that there were zero elements within cur #
# next() tells R to just skip/ignore this case #
# otherwise, take any number j from the range 1 to the num_to (the number of# 
# elements in cur) and use it to subset curvec #
# newedge is a new vector (current vertex, edge in vertex, corresponding weight) #

#is_undirected
#to check whether its edge data frame is symmetric
is_undirected <- function(g){
  edges <- edge(g)
  for(i in 1:nrow(edges)){
    istart <- edges[i,]$start
    iend <- edges[i,]$end
    iweight <- edges[i,]$weight
    if(is.null(edges[edges$start == iend & edges$end == istart,]$weight))
      return(FALSE)
    if(edges[edges$start == iend & edges$end == istart,]$weight != iweight)
      return(FALSE)
  } 
  return(TRUE)
}

is_isomorphic = function(g1, g2){
  if(length(g1) != length(g2)){
    stop("Two graphs do not have same number of vertices")
  }
  for(i in length(g1)){
    if(names(g1[i]) != names(g2[i])){
      stop("Name of vertices are not the same")
    if(length(g1[[i]]) != length(g2[[i]])){
      stop("Different number of edges/weights")
    }
    }
  }
  
}

#This function is for taking difference between two data frames
diff_df <- function(df1,df2,...){
  expr <- paste("subset(df1,", paste(sapply(names(df1), function(x){paste("!(", x, " %in% df2$", x, ")", sep="")}), collapse=" | "), ")")
  eval(parse(text=expr))
}



#is_connected function
is_connected <- function(g, v1, v2){
  #ensure if the graph is valid or not
  #if(!is_valid(g)){
  #  stop("Please input a valid graph.")
  #}
  
  #check if v1 and v2 are in the graph 
  edges <- edge(g)
  for(i in 1:nrow(edges)){
    istart <- edges[i,]$start #build array of the start vertices
    iend <- edges[i,]$end #build array of the end vertices 
    if(v1!=start | v1!=end) #compare whether v1 is in either the start or the end array
      return("v1 is not in the graph")
    if(v2!=start[i] | v2!=end[i]) #compare whether v2 is in either the start or the end array
      return("v2 is not in the graph")
    }
  
  
for(i in 1:length(g)){
    if()
  } 
  edges <- edge(g)
}



#shortest path
shortest_path <- function(g,v1,v2){
  if(!is_valid(g)){
    stop("Please input a valid graph.")
  }
  #The following code will apply Dijkstra's Algorithm
  edges <- edge(g)
  vinfo <- data.frame(v = character(),dist = numeric(),prev = numeric())
  unvisited <- c(names(g))
  for(vert in unvisited){
    newvert <- c(vert,Inf,NULL)
    vinfo <- rbind(vinfo,setNames(as.list(newvert), names(vinfo)))
  }
  
  vinfo[vinfo$v == v1,]$dist <- 0
  
  while(!is.null(unvisited)){
    temp <- vinfo[vinfo$v %in% univisted,]
    u <- temp[temp$dist == min(temp$dist),][1,]$v   #vertex in unvisited with min dist[u]  
    if(temp[temp$v == u,]$dist == Inf){
      return(c())
    }
    unvisited <- unvisited[unvisited != u]          #remove u from unvisited
    
    for(vert in edges[edges$start == u,]$end){      #for each neighbor u can go to
      d <- vinfo[vinfo$v == u,]$dist + edges[edges$start == u & edges$end == vert,]weight
      if(d < dist[vert]){                           # A shorter path to vert has been found
        vinfo[vinfo$v == vert,]$dist <- d
        vinfo[vinfo$v == vert,]$prev <- u
      }
    }
  }
  path <- c(v2)
  vert <- v2
  while(!is.null(vinfo[vinfo$v == vert,]$prev)){
    path <- c(path,vinfo[vinfo$v == vert,]$prev)
    vert <- vinfo[vinfo$v == vert,]$prev
  }
  
  return(rev(path))
}




#minimum spanning tree
min_span_tree <- function(g){
  if(!is_valid(g)){
    stop("Please input a valid graph.")
  }
  
  if(!is_undirected){
    stop("Please input an undirected graph")
  }
  
  edges <- edge(g)
  #Remove redundancies for the edge table of an Undirected graph
  edges <- edges[edges$start < edges$end,]
  #   #The following code will apply Kruskal's Algorithm
  #   #However I find Kruskal's Algorithm is hard to implement
  #   edges <- edges[order(edges$weight,edges$start,edges$end),]
  #   MST <- 
  #   
  #   while(!is_connected_graph(MST)){
  #     #keep adding the minimal edge to MST
  #   }
  
  #The following code will apply Prim's Algorithm
  edges <- edges[order(edges$weight,edges$start,edges$end),]
  MST <- edges[1,]
  vertices <- list(MST$start,MST$end) #record all the vertices in MST
  while(length(MST) < length(g) - 1){
    neighbor <- edges[(edges$start %in% vertices | edges$end %in% vertices) & (!(edges$start %in% vertices) | !(edges$end %in% vertices)),]
    neighbor <- diff_df(neigbor,MST)
    #protection for non-connected components
    if(nrow(neighbor) == 0){
      stop("The input graph is not connected.")
    }
    MST <- rbind(MST,setNames(as.list(neighbor[1,]), names(MST)))
    vertices <- list(MST$start,MST$end)
  }
  


```



