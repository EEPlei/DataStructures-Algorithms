Team4 Duke Dinosaurs HW 1 Write Up
```{r}
source("graph.r")
```

is_isomorphic()

The purpose of this function is that given two graph objects, the function will give us TRUE if isomorphic, and FALSE if not. If two graphs are isomorphic, the vertices, edges, and weights are identical. Say we have vertex A in the first graph, and it connects to vertex B with weight w. We should also have a vertex A in the second graph that connects to vertex B with weight w. I call them vertex A and vertex B, because isomorphic graphs will be comparing the names of the vertices, not their position within the graph. This should hold true for the entire graph. 

First thing to note. We have created a helper function called edge. Edge takes a graph object and creates a data frame with three columns, start, end, and weight. The start and end columns will contain the name of the vertices. Weight will be a column of numbers. Each row will represent an edge and list the starting vertex, ending vertex and the weight. 

The first thing we do in the function is to test if it both graphs are valid by plugging them into the is_valid function that was already written. There's no point in testing invalid graphs for isomorphism. 

Next, we put each graph through the edge function to obtain dataframes. We then test to see if these two dataframes have the same number of rows or in other words, edges going in one direction. So, although vertex A is going to vertex B with weight w, and vertex B is going to vertex A with weight w, this will show up as A B w and B A w - 2 separate timese in our dataframe. In a special case, it is possible for our dataframe to have 0 rows. This is a result from a graph with a vertex that doesn't link to anything and has no weight. In this case, the only graph it would equal to is a graph with a single vertex of the same name that also doesn't link to anything and has no weight. 

Since our dataframe can't have a negative number of rows, we now consider the remaining case; where our dataframe has 1 or more rows. We use a for loop to run through all the different rows in our first graph's dataframe. We find the entry for the start, end, and weight for the ith row and store them inside variables for ease of use later on. We test to see if the starting vertex in our first graph is a starting vertex anywhere in our second graph. If there is, we store the indexes of those rows in a variable. Now, we check to see if our ending vertex in graph 1 is a ending vertex in any of those rows with the same starting vertex. If there is, there should only be one. We find the weight for that row in our second graph's dataframe with the same starting and ending vertex. Should that weight be equal to the first graph's weight we found earlier, we have an identical edge. Going through all the rows in our first graph's dataframe, if we find an identical edge for all of them in our second graph's dataframe, the two graphs are isomorphic. Remember, we made sure that our two graphs have the same number of edges at the very beginning. As such, there is no way for our second graph to contain all the edges our first graph does and some additional edge (which wouldn't have made the two graphs isomorphic). 



is_connected() 

Before running the function, we first run a series of checks on our input variables. We first check if the graph is valid or not. We then check whether or not our edges are null. Then we check if the edges are of the types "logical"--for example, if the user puts in is_connected(g1, v1, "TRUE") then the function throws an error that one of the edges specified is not a valid entry. We also check if the edges our numeric variables. If they are, then our function throws an error so that the user can input a character value into v1 and v2. Lastly, if the edges are not in the graph utilized, then the function also throws an error. We implemented a recursion process in running our is_connected() function. We first call up the function is_connected_helper(), which indexes the vertices that we've already passed when we "walk" from one edge to the other. We use a "seen" array to keep track of the list of vertices the function has already checked. The reasoning for tracking the list of visited vertices is to prevent an infinite recursion when two vertices point to each other. If we have already seen the vertex, then the function passes that vertex and moves on to the next edge. The final output is_connected(g, v1, v2) tells us whether or not edge v1 is connected to edge v2. If v1 and v2 are connected, return TRUE and if v1 and v2 are not connected returns FALSE.  

