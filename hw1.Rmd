Homework 1 - TeamName
========================================================
#edge
#edge function will return a data frame which is a table summarizing all edges.
#Its first column stores the starting vertices and its second column stores the ending vertics
#Its third column stores the edge length
edge <- function(g){
  output <- data.frame(start = numeric, end = numeric, weight = numeric)
  for(i in 1:length(g)){
    cur <- graph[i]
    curvec <- unlist(cur)
    num_to <- length(curvec)/2 #number of vertices the current vertex can go to
    if(num_to)==0)
      next
    for(j in 1:num_to){
      newedge <- c(i,curvec[j],curvec[j*2])
      output <- rbind(output,setNames(as.list(newedge), names(output)))
    }
  }
}

#is_undirected
#to check whether its edge data frame is symmetric
is_undirected <- function(g){
  edges <- edge(g)
  
  return false
}

#shortest path
shortest_path <- function(g,v1,v2){
  if(!is_valid(g)){
    stop("Please input a valid graph.")
  }
  
  #The following code will apply Dijkstra's Algorithm
  
  return
}

#Is_connected_graph
#This function checks whether the graph is a connected entity as a whole
is_connected_graph<-function(g){
  edges <- edge(g)
  if(all((1:length(g) %in% c(edges$start,edges$end))))
    return true
  else
    return false
}

#minimum spanning tree
min_span_tree <- function(g){
  if(!is_valid(g)){
    stop("Please input a valid graph.")
  }
  
  if(!is_undirected){
    stop("Please input an undirected graph")
  }
  
  #The following code will apply Kruskal's Algorithm
  MST <- min
  
  while(!is_connected_graph(MST)){
    #keep adding minimum edge to MST
  }
  
  return MST
}
